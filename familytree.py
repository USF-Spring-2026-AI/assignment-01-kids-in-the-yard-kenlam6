# -*- coding: utf-8 -*-
"""familyTree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PsUW_9UPsQrPZI3SDo6aEWPY44hU-nNX
"""

import pandas as pd
import random
import math

class Person:

    def __init__(self, name, decade, last, children, parents):
        self._name = name
        self._decade = decade
        self._last = last
        self.children = []
        self.birth_year = None
        self._parents = []
        self._spouse = None


    # getter methods

    def get_name(self):
        return self._name

    def get_last(self):
        return self._last

    def get_decade(self):
        return self._decade

    def get_birth_year(self):
        return self._birth_year

    def get_full(self):
        return f"{self._name} {self._last}"

    # setter methods

    def set_last(self, last):
        self._last = last

    def set_birth_year(self, year):
        self._birth_year = year

    def set_spouse(self, spouse):
        self._spouse = spouse

    def add_child(self, child):
        self.children.append(child)

    def add_parent(self, parent):
        self._parents.append(parent)

class PersonFactory:

    def __init__(self):
      names = "/content/drive/MyDrive/family tree data/first_names.csv"
      self.first_names = pd.read_csv(names)

      last = "/content/drive/MyDrive/family tree data/last_names.csv"
      self.last_names = pd.read_csv(last)

      rank_prob = "/content/drive/MyDrive/family tree data/rank_to_probability.csv"
      self.prob = pd.read_csv(rank_prob, header=None)

      birth = "/content/drive/MyDrive/family tree data/birth_and_marriage_rates.csv"
      self.child = pd.read_csv(birth)

      life = "/content/drive/MyDrive/family tree data/life_expectancy.csv"
      self.life = pd.read_csv(life)


      # create probability dict
      self.rank_to_prob = {}
      first_row = self.prob.iloc[0]  # get the only row
      for i in range(len(first_row)):
          rank = i + 1
          self.rank_to_prob[rank] = float(first_row[i])


    def create_root(self):
      couple = []
      # Desmond
      desmond = Person(
          name="Desmond",
          decade="1950s",
          last="Jones",
          birth_year=1950,
      )
      couple.append(desmond)

      # Molly
      molly = Person(
          name="Molly",
          decade="1950s",
          last="Smith",
          birth_year=1950,
      )

      molly.set_last("Jones")
      couple.append(molly)

      desmond.set_spouse(molly)
      molly.set_spouse(desmond)
      return couple

    def select_name(self, decade):
      names = []
      freqs = []

      for _, row in self.first_names.iterrows():
          if row['decade'] == decade:
              names.append(row['name'])
              freqs.append(float(row['frequency']))

          if sum(freqs) > 0:
          # grab one name using weighted random
            chosen = random.choices(names, weights=freqs, k=1)[0]
            return chosen

    def last_name_prob(self):
        lastname_info = {}
        # build rank
        rank_to_prob = {}
        first_row = self.prob.iloc[0].tolist()   # convert row to list
        # get index and value
        for i, prob_value in enumerate(first_row):
            # match 0 with 1
            rank = i + 1
            # store with rank as key
            rank_to_prob[rank] = float(prob_value)

        # Now combine with last names
        for _, row in self.last_names.iterrows():
            rank = int(row['Rank'])
            lastname_info[rank] = {
                'LastName': row['LastName'],
                'Decade': row.get('Decade'),
                'prob': rank_to_prob.get(rank, 0.0) # assign 0.0 place holder if rank doesnt exist
            }
        return lastname_info

    def get_number_of_child_rate(self, birth_decade):
        # dictionary with decade as key and birth_rate as value
        self.birth_rates = {}
        for _, row in self.child.iterrows():
            decade = row['decade']
            birth_rate = row['birth_rate']
            self.birth_rates[decade] = birth_rate

        base_rate = self.birth_rates[birth_decade]

        # calculate min/max children
        min_children = math.ceil(base_rate - 1.5)
        max_children = math.ceil(base_rate + 1.5)

        min_children = max(0, min_children) # no neg child
        if min_children == 0:
            min_children = 1

        # decide number of children
        num_children = random.randint(min_children, max_children)
        return num_children

    def calculate_child_birth_years(self, parent_birth_year, num_children):
        child_years = []

        # even spacing between 25 and 45
        start_age = 25
        end_age = 45

        # if multiple children, distribute them evenly across the range
        if num_children > 0:
            if num_children == 1:
                # single child, pick middle of the range
                child_years.append((start_age + end_age) // 2)
            else:
                # multiple children to distribute evenly
                step = (end_age - start_age) / (num_children - 1)

                for i in range(num_children):
                    year = start_age + round(i * step)
                    child_years.append(parent_birth_year + year)

        return child_years

    def year_to_decade(self, year):

      decade_start = (year // 10) * 10
      return f"{decade_start}s"

factory = PersonFactory()